var Express = require('express');
var axios = require('axios');
var https = require('https');
var bodyParser = require('body-parser');
var fs = require('fs');
var admin = require("firebase-admin");
var renderToString = require("react-dom/server");
var React = require('react');
var renderToString = require('react-dom/server');
var stripe = require("stripe")("[REDACTED]");
var app = Express();
var serviceAccount = require("./serviceAccountKeyJSON");


app.use(bodyParser.urlencoded({ extended: false }))

// parse application/json
app.use(bodyParser.json())

// General setup
app.use( function(req, res, next) {
    res.header("Access-Control-Allow-Origin", "*");
    res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
    next();
});

// This is the port we are using. It will default to our System default but, in test mode, it is set to port 1234. This was done so that it doesn't conflict with the default blockchain ports.
var port = process.env.PORT || 1234;


admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
  databaseURL: "https://donate-rcocuzzo-17387568.firebaseio.com"
});

function log(output) {
    console.log(output)
}

function logn(output) {
    console.log('\n' + output)
}

// Get a reference to the root of the Database
var root = admin.database();

var canPostEvents = async (uid) => {
    
  var event_ref = root.ref('/users/' + uid + '/canPostEvents');
  return new Promise( function (resolve, reject) {
    event_ref.once('value').then(function(snapshot, err) {
      if (err) {
        reject(err.message);
      } else {
        resolve(snapshot.val());
      }
    });
  })
}

// Get the priveledges of a user
app.get('/eventPriviledges', (req, res)  => {
    log('\n' + 'Getting event priveledges.')
    
    var idToken = req.query.idToken;

    admin.auth().verifyIdToken(idToken)
      .then(function(decodedToken) {
        
            if (decodedToken) {
                var uid = decodedToken.uid;
                
                canPostEvents(uid).then(function(canPost) {
                    log('User can post: ' + canPost)
                    if (canPost != null) 
                        res.send( canPost );
                    else 
                        res.send(false); 
                }).catch(function(err) {
                    log('err: ' + err)
                    res.send(false);
                })
            } else {
                log('No decoded token!')
                res.send(false);
            }
        
      }).catch(function(error) {
        log('err!')
        // Handle error
        res.send(false);
      });

})

// Get the priveledges of a user
app.post('/createEvent', (req, res)  => {
    
    var idToken = req.body.params.idToken;
    var event = req.body.params.event;

    admin.auth().verifyIdToken(idToken)
      .then(function(decodedToken) {
        if (decodedToken) {
            var uid = decodedToken.uid;
            let ref = root.ref('/db/events/');
            // Generate a reference to a new location and add some data using push()
            var newPostRef = ref.push(event);
            // Get the unique ID generated by push() by accessing its key
            var postID = newPostRef.key;
            res.send(true);
        } else {
            res.send(false);
        }
        
      }).catch(function(error) {
        // Handle error
        res.send(false);
      });
    
    
})

app.get('/createStripeUser', (req,res) => {
    
    var idToken = req.query.idToken;
    var paymentToken = req.query.paymentToken;
    var plan = req.query.plan;
    
    var amount;
    
    if (plan) {
        if (plan == 'Premium X')
            amount = 2000;
        else if (plan == 'Premium Y')
            amount = 1500;
        else if (plan == 'Premium Z')
            amount = 1000;
        else
            res.send('69_69_69');
    }
    
    admin.auth().verifyIdToken(idToken)
      .then(function(decodedToken) {
        
            if (decodedToken) {
              var uid = decodedToken.uid;
              var email = decodedToken.email;
                
              // Create a Customer:
              const customer = await stripe.customers.create({
                source: paymentToken,
                email: email,
              }).then(
                  function(customer_id) {

                      // Charge the Customer instead of the card:
                      const charge = await stripe.charges.create({
                        amount: amount,
                        currency: 'usd',
                        customer: customer_id,
                      }).then(
                          
                          function(response) {
                              
                              stripe.subscriptions.create({
                                  customer: customer_id,
                                  items: [
                                    {
                                      plan: plan,
                                    },
                                  ],
                                }, {
                                  stripe_account: "[REDACTED]",
                                }, function(err, subscription) {
                                  // asynchronously called
                                  
                                });
                              
                          });
                  
                  
                 })
      



  // YOUR CODE: Save the customer ID and other info in a database for later.


                
                
                
            } else {
                log('No decoded token!')
                res.send(false);
            }
        
      }).catch(function(error) {
        log('err!')
        // Handle error
        res.send('Invalid inputs!');
      });

})

app.listen(port, () => console.log('Server running on port '+ port + '!\n'))